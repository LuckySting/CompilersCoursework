\section{Конструкторский раздел}\label{sec:construct}

\subsection{Структура компилятора}\label{subsec:structure}
Компилятор состоит из 3-ех модулей:
\begin{itemize}
    \item лексический анализатор, преобразовывающий текст программы в поток токенов;
    \item синтаксический анализатор, строящий AST-дерево;
    \item генератор LLRM IR кода.
\end{itemize}

\subsection{Генерация лексического и синтаксического анализатора}\label{subsec:lex_synt_gen}
В качестве входных данных для ANTLR выступает файл с описанием грамматики исходного языка.
Данный файл содержит только правила грамматики без добавления кода, исполнение которого соответствует
применению определённых правил.
Подобное разделение позволяет использовать один и тот же файл грамматики для построения различных приложений
(например, компиляторов, генерирующих код для различных сред исполнения).

На основе правил заданной грамматики языка ANTLR генерирует класс нисходящего рекурсивного синтаксического анализатора.
Для каждого правила грамматики в полученном классе имеется свой рекурсивный метод.
Разбор входной последовательности начинается с корня синтаксического дерева и заканчивается в листьях.

Сгенерированный ANTLR синтаксический анализатор выдаёт абстрактное синтаксическое дерево в чистом виде, и реализует методы для
его построения и последующего обхода.
Дерево разбора для заданной входной последовательности символов можно получить, вызвав метод, соответствующий аксиоме
в исходной грамматике языка.
В грамматике языка Golang аксиомой является нетерминал sourceFile, поэтому построение дерева следует начинать с вызова
метода sourceFile() объекта класса синтаксического анализатора, являющегося корнем дерева.

\subsection{Обнаружение и обработка лексических и синтаксических ошибок}\label{subsec:errors}
Все ошибки, которые обнаруживаются лексическим и синтаксическим анализаторами ANTLR, по умолчанию выводятся в стандартный поток вывода ошибок.
Данные ошибки возможно перехватить стандартным обработчиком ошибок языка на котором ведется разработка компилятора.

\subsection{Генерация кода}\label{subsec:codegen}
Компилятор генерирует файл типа LLVM IR (Low Level Virtual Machine Intermediate representation),
являющийся промежуточным представлением генерируемого кода для виртуальной машины LLVM.

Данный файл содержит инструкции описывающие ход выполнения программы на языке более высокого уровня, чем Ассемблер.
Такой подход позволяет описывать код программы более естественным образом.
LLVM IR позволяет зарегистрировать следующие типы данных:
\begin{itemize}
    \item целые числа произвольной разрядности;
    \item числа с плавающей точкой: float, double, а также ряд типов,
    специфичных для конкретной платформы (например, x86\_fp80);
    \item указатели;
    \item массивы;
    \item структуры;
    \item векторы;
    \item функции.
\end{itemize}

Большинство инструкций в LLVM принимают два аргумента(операнда) и возвращают одно значение(трёхадресный код).
Значения определяются текстовым идентификатором.
Локальные значения обозначаются префиксом \%, а глобальные — @.
Локальные значения также называют регистрами, а LLVM — виртуальной машиной с бесконечным числом регистров.

Тип операндов всегда указывается явно, и однозначно определяет тип результата.
Операнды арифметических инструкций должны иметь одинаковый тип, но сами инструкции «перегружены» для любых числовых типов и векторов.

Код модуля кодогенерации представлен на GitHub

\texttt{https://github.com/LuckySting/pygoco}.