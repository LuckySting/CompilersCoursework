\section{Аналитический раздел}\label{sec:analytic}
В разделе приводится описание обобщенной архитектуры компилятора, особенности языка Golang и платформы LLVM.

\subsection{Архитектура комплятора}\label{subsec:architecture}
Компилятор производит перевод кода программы, написанного на одном языке, в эквивалетный код на другом языке.
Этот процесс условно делится на две части: анализ и кодогенерация~\cite{aho_compilers}.

Анализ состоит из трех фаз: лексической, синтаксической и семантической.

\subsubsection{Лексический анализ}\label{lexical_analyz}
На этапе лексического анализа входная последовательность символов, пердставляющих из себя текс на некотором языке
программирования, преобразуется в поток лексем (токенов).
На этом этапе возможно обнаружения лексических ошибок, таких как наличие неподдерживаемых символов, или, например,
некорректная запись идентификатора или числовой константы.
Полученным токенам могут назначаться типы, сохраняться информация об их местоположении в исходном коде~\cite{aho_compilers}.

Лексический анализ может быть представлен и как самостоятельная фаза анализа, и как составная часть фазы синтаксического анализа.
В первом случае лексический анализатор реализуется в виде отдельного модуля, который принимает последовательность символов, составляющих
текст компилируемой программы, и выдаёт список обнаруженных лексем.
Во втором случае лексический анализатор фактически является подпрограммой, вызываемой синтаксическим анализатором для получения
очередной лексемы~\cite{based}.

Правила разбиения текста программы на токены могут быть заданы с помощью грамматики языка или регулярных выражений.

\subsubsection{Синтаксический анализ}\label{subsubsec:syntax_analyz}
Синтаксический анализ, или разбор, как его еще называют, – это процесс сопоставления последовательности
токенов исходного языка с его формальной грамматикой. Данная фаза анализа выполняется при помощи программы-парсера,
принимающей на вход поток лексем, в случае, когда лексический анализ выполняется отдельно, или исходный код программы в
ином случае. Результатом работы парсера является дерево разбора (или абстрактное синтаксическое дерево),
узлами дерева являются оперции, а дочерние узлы являются аргументами операции.

Синтаксический анализатор фиксирует синтаксические ошибки, т.е. ошибки, связанные с нарушением правил построения
текста на языке программирования, задаваемых формальной грамматикой~\cite{aho_syntax}.

Существующие алгоритмы синтаксического анализа можно объеденить в две категории: алгоритмы восходящего и нисходящего анализа.

Нисходящий анализ применим к текстам, построенным по правилом контекстно-свободной LL грамматикам. LL означает, что
разбор происходит слева направо и строится левый вывод.

Примером алгоритма нисходящего анализа является рекурсивный спуск. Суть алгоритм заключается в рекурсивном применении
правл граматики к входной последовательности лексем с их последовательным "поглощением". Для корректной работы алгоритма
требуется отсутсвие так называемой левой рекурсии в грамматике.

При восходящем анализе дерево строится от листьев к корню. Сначала распознаются правила грамматики, содержащие в правой
части терминалы, затем те, которые содержат в правой части левые части предыдущих правил и так далее.
Таким образом на каждом шаге свертки некоторая подстрока, соответствующая правой части продукции, замещается левым символом данной продукции.
Примером алгоритма этого типа служит таблично управляемый анализатор операторного предшествия.
Этот алгоритм использует операции "перенос/свертка", применим для LR грамматик.

\subsubsection{Семантический анализ}\label{subsubsec:semantic_analyz}
На данном этапе анализируется построенное парсером дерево выражений с целью интерпретации распознанных конструкций
и их связей между собой, например, связь переменной с её типом данных, значением, областью видимости.

Семантический анализ позволяет перестроить дерево разбора с учетом смысла конструкций, а также распознать такие ошибки, как:
\begin{itemize}
    \item несоответствие типов;
    \item необъявленные переменные;
    \item множественные объявления переменной;
    \item отсутствие переменной в области видимости;
    \item несоответствие параметров.
\end{itemize}

В результате семантического анализа дерево приводится к виду, пригодному для генерации кода~\ref{based}.

\subsubsection{Кодогенерация}\label{subsubsec:codegen}
В ходе этого этапа компиляции происходит обход полученного в результате анализа дерева.
Для каждого узла, предствляющего из себя операцию, создается одна или несколько инструкций на целевом языке.
На этапе генерации кода полагается, что входное дерево не содержит ошибок.

В ходе генерации или после неё может также проводится оптимизация полученного набора инструкций с помощью программы-оптимизатора.

\subsubsection{Стандартные средства построения анализаторов}\label{subsubsec:std}
Имеется множество различных стандартных средств для построения синтаксических анализаторов: Lex и Yacc, Coco/R, ANTLR, JavaCC и др.
Генератор Yacc предназначен для построения синтаксического анализатора контекстно-свободного языка.
Анализируемый язык описывается с помощью грамматики в виде, близком форме Бэкуса-Наура.
Результатом работы Yacc'a является программа на Си, реализующая восходящий LALR(1) распознаватель.
Как правило, Yacc используется в связке с Lex – стандартным генератором лексических анализаторов.
Для обоих этих инструментов существуют свободные реализации – Bison и Flex.

Сосо/R читает файл с атрибутивной грамматикой исходного языка в расширенной форме Бэкуса – Наура и создает файлы
лексического и синтаксического анализаторов.
Лексический анализатор работает как конечный автомат.
Синтаксический анализатор использует методику нисходящего рекурсивного спуска.

ANTLR (ANother Tool for Language Recognition) – это генератор синтаксических анализаторов для чтения, обработки или
трансляции как структурированных текстовых, так и бинарных файлов.
ANTLR широко используется для разработки компиляторов, прикладных программных инструментов и утилит.
На основе заданной грамматики языка ANTLR генерирует код синтаксического анализатора, который может строить
абстрактное синтаксического дерево и производить его обход~\cite{antlr}.

Все рассмотренные средства включают в себя лексический анализ на основе входной грамматики.

\subsection{Язык Golang}\label{subsec:grammar}
Golang это высокоуровневый компилируемый язык программирования, ориентированный на написание многопоточных приложений.
В качестве особенностей этого языка можно выделить:
\begin{enumerate}
    \item концепция использования "зеленых потоков";
    \item строгая грамматика;
    \item наличие небольшого рантайма, включающего только планеровщик и сборщик мусора;
    \item компилируемость;
    \item отсутсвие синтаксического сахара;
    \item строгая типизация.
\end{enumerate}.

Для реализации было выбрано подмножество языка Golang, содержащее базовые его возможности:
\begin{enumerate}
    \item создание и использование переменных;
    \item типы данных float, int, array;
    \item арифметические выражения;
    \item логические выражения;
    \item подпрограммы func;
    \item цикл for;
    \item оператор ветвления if-else;
    \item оператор printf, аналогичный fmt.Printf из стандартной библиотеки Golang;
\end{enumerate}.

Грамматика в формате ANTLR представлена в приложении А.

\subsection{LLVM}\label{subsec:llvm}
LLVM – проект программной инфраструктуры для создания компиляторов.
В основе инфраструктуры лежит платформонезависимая система кодирования машинных инструкций – байткод LLVM IR (Intermediate
Representation).

LLVM IR в отличие от ассемблера является платформонезависимым, а его инструкции перегруженны для множества типов данных.
LLVM IR может выполняться как самой виртуальной машиной LLVM, так и быть транслирован в байткод для множества платформ,
включая ARM, x86, x86-64, GPU от AMD и Nvidia и другие.

LLVM IR позволяет зарегистрировать следующие типы данных:
\begin{itemize}
    \item целые числа произвольной разрядности;
    \item числа с плавающей точкой: float, double, а также ряд типов,
    специфичных для конкретной платформы (например, x86\_fp80);
    \item указатели;
    \item массивы;
    \item структуры;
    \item векторы;
    \item функции.
\end{itemize}
Кроме того имеется возможность создания множества связанных модулей.

Большинство инструкций в LLVM принимают два аргумента(операнда) и возвращают одно значение(трёхадресный код).
Значения определяются текстовым идентификатором.
Локальные значения обозначаются префиксом \%, а глобальные — @.
Локальные значения также называют регистрами, а LLVM — виртуальной машиной с бесконечным числом регистров.
Тип операндов всегда указывается явно, и однозначно определяет тип результата.
Операнды арифметических инструкций должны иметь одинаковый тип, но сами инструкции «перегружены» для любых числовых типов и векторов.

В данной работе реализуется генерация кода LLVM IR с помощью binding'а для языка Python: llvmlite~\cite{llvm}.
