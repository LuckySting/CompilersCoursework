\section{Аналитический раздел}\label{sec:analytic}

\subsection{Лексический и синтаксический анализ}\label{subsec:lexical_syntax}
Задачей лексического анализа является аналитический разбора входной последовательности символов составляющих текст
компилируемой программы с целью получения на выходе последовательности символов, называемых «токенами», которые
характеризуются определенными типом и значением.

Лексический анализатор функционирует в соответствии с некоторыми правилами построения допустимых входных последовательностей.
Данные правила могут быть определены, например,в виде детерминированного конечного автомата, регулярного выражения или праволинейной грамматики.
С практической точки зрения наиболее удобным способом является формализация работы лексического анализатора с помощью грамматики.

Лексический анализ может быть представлен и как самостоятельная фаза трансляции, и как составная часть фазы синтаксического анализа.
В первом случае лексический анализатор реализуется в виде отдельного модуля, который принимает последовательность символов, составляющих
текст компилируемой программы, и выдаёт список обнаруженных лексем.
Во втором случае лексический анализатор фактически является подпрограммой, вызываемой синтаксическим анализатором для получения
очередной лексемы~\cite{based}.

В процессе лексического анализа обнаруживаются лексические ошибки – простейшие ошибки компиляции, связанные с наличием
в тексте программы недопустимых символов, некорректной записью идентификаторов, числовых констант и пр.

Синтаксический анализ, или разбор, как его еще называют, – это процесс сопоставления линейной последовательности
токенов исходного языка с его формальной грамматикой.
Результатом обычно является дерево разбора (или абстрактное синтаксическое дерево).

Синтаксический анализатор фиксирует синтаксические ошибки, т.е. ошибки, связанные с нарушением принятой структуры программы.

\subsection{Методы реализации лексического и синтаксического анализаторов}\label{subsec:methods}
Лексический и синтаксический анализаторы могут быть разработаны «с нуля» на основе существующих алгоритмов анализа,
а могут быть созданы с помощью стандартных средств генерации анализаторов.

Существуют две основные стратегии синтаксического анализа: нисходящий анализ и восходящий анализ.

\subsubsection{Алгоритмы лексического и синтаксического анализа}\label{subsubsec:algos}
В нисходящем анализе дерево вывода цепочки строится от корня к листьям, т.е. дерево вывода «реконструируется»
в прямом порядке, и аксиома грамматики «развертывается» в цепочку.
В общем виде нисходящий анализ представлен в анализе методом рекурсивного спуска, который может использовать откаты,
т.е. производить повторный просмотр считанных символов~\cite{aho_compilers}.

В восходящем анализе дерево вывода строится от листьев к корню и анализируемая цепочка «сворачивается» в аксиому.
На каждом шаге свертки некоторая подстрока, соответствующая правой части продукции, замещается левым символом данной продукции.
Примерами восходящих синтаксических анализаторов являются синтаксические анализаторы приоритета операторов, LR-анализаторы (SLR, LALR)~\cite{aho_compilers}.

\subsubsection{Стандартные средства}\label{subsubsec:std}
Имеется множество различных стандартных средств для построения синтаксических анализаторов: Lex и Yacc, Coco/R, ANTLR, JavaCC и др.
Генератор Yacc предназначен для построения синтаксического анализатора контекстно-свободного языка.
Анализируемый язык описывается с помощью грамматики в виде, близком форме Бэкуса-Наура.
Результатом работы Yacc'a является программа на Си, реализующая восходящий LALR(1) распознаватель.
Как правило, Yacc используется в связке с Lex – стандартным генератором лексических анализаторов.
Для обоих этих инструментов существуют свободные реализации – Bison и Flex.

Сосо/R читает файл с атрибутивной грамматикой исходного языка в расширенной форме Бэкуса – Наура и создает файлы
лексического и синтаксического анализаторов.
Лексический анализатор работает как конечный автомат.
Синтаксический анализатор использует методику нисходящего рекурсивного спуска.

ANTLR (ANother Tool for Language Recognition) – это генератор синтаксических анализаторов для чтения, обработки или
трансляции как структурированных текстовых, так и бинарных файлов.
ANTLR широко используется для разработки компиляторов, прикладных программных инструментов и утилит.
На основе заданной грамматики языка ANTLR генерирует код синтаксического анализатора, который может строить
абстрактное синтаксического дерево и производить его обход.

\subsection{Построение грамматики}\label{subsec:grammar}
Для реализации было выбрано подмножество языка Golang, содержащее основные его возможности:
\begin{enumerate}
    \item создание и использование переменных;
    \item типы данных float, int, array;
    \item арифметические выражения;
    \item логические выражения;
    \item подпрограммы func;
    \item цикл for;
    \item оператор ветвления if-else;
    \item оператор printf, аналогичный fmt.Printf из стандартной библиотеки Golang;
\end{enumerate}.

\subsubsection{Лексер}\label{subsubsec:lexer}
В листинге~\ref{lst:lexer} представлена часть кода лексера, полный код находится в приложении А.
\begingroup
\lstinputlisting[lastline=20, caption={Лексер},label={lst:lexer}]{code/GoLexer.g4}
\endgroup

\subsubsection{Парсер}\label{subsubsec:parser}
В листинге~\ref{lst:parser} представлена часть кода парсера, полный код находится в приложении Б.
\begingroup
\lstinputlisting[lastline=20, caption={Парсер},label={lst:parser}]{code/GoParser.g4}
\endgroup

\subsection{Инструменты генерации синтаксического и лексического анализаторов}\label{subsec:tools}
Выше были рассмотрены такие инструменты генерации синтаксических анализаторов: Lex и Yacc, Coco/R, ANTLR.

Принимая во внимание эффективность и простоту использования ANTLR, для построения кода синтаксического анализатора
было решено применить данное средство~\cite{antlr}.

\subsection{Генерация кода}\label{subsec:generation}
Генерация кода осуществляется с помощью нисхождения по абстрактному синтаксическому дереву,
полученному в результате синтаксического анализа.
Для каждого узла дерева определяется его тип и связанное с ним правило в грамматике языка.
Исходя из этой информации генерируется промежуточный код на языке LLVM IR для исполнения на виртуальной машине или
компиляции в исполняемый файл посредством использования инструмента LLC~\cite{llvm}.